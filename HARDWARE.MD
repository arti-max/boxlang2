## Руководство по периферии GovnoCore32-20020

Это руководство описывает низкоуровневое взаимодействие с аппаратным обеспечением платформы GovnoCore32. Весь контроль над периферией осуществляется через два основных механизма:

1. **Память-отображаемый ввод-вывод (Memory-Mapped I/O):** Управление устройствами путем чтения и записи данных по определённым физическим адресам в памяти. Это основной способ работы с GPU.
2. **Программные прерывания:** Вызов специальных подпрограмм, зашитых в эмулятор, для выполнения сложных действий, таких как обновление экрана или генерация звука.

### 1. Графический процессор (GPU - GovnGraphics)

GPU управляется в основном через запись данных в его регистры и видеопамять, которые отображены на общую карту памяти.

#### 1.1. Ключевые адреса памяти GPU

| Адрес | Назначение | Тип данных для записи | Описание |
| :-- | :-- | :-- | :-- |
| `0x49FF00` | **Регистр видеорежима** | `char` | Определяет, как GPU интерпретирует данные. Запись `1` включает графический режим 640x480 с 256-цветной палитрой[^3]. Запись `2` включает текстовый режим. |
| `0x4A0000` | **Таблица палитры** | `num16` | Область размером 512 байт (`256 цветов * 2 байта/цвет`), хранящая палитру. |
| `0x400000` | **Видеопамять (Framebuffer)** | `char` | Область размером 307,200 байт (`640 * 480`), представляющая "холст" для рисования. |

#### 1.2. Работа с графикой: Шаг за шагом

**Шаг 1: Инициализация графического режима**
Перед началом любых операций рисования необходимо переключить GPU в графический режим.

```rust
## Функция для переключения в графический режим
box init_graphics_mode[] (
    ## Указатель на регистр видеорежима
    char* video_mode_reg : 0x49FF00
    ## Записываем '1', чтобы включить графический режим 640x480
    @video_mode_reg : 1
)
```

**Шаг 2: Настройка палитры**
Цвета в графическом режиме определяются палитрой. Вы можете настроить любой из 256 доступных цветов. Каждый цвет описывается 16-битным значением в формате **RGB555LE** (5 бит на красный, 5 на зелёный, 5 на синий, Little Endian)[^3].

Чтобы собрать цвет, используйте битовые операции:

`| 0 | R R R R R | G G G G G | B B B B B |`

```rust
## Функция для установки цвета в палитре
##- col: 16-битное значение цвета
##- index: номер ячейки в палитре (0-255)
box set_palette_color[num16 col, num32 index] (
    ## Вычисляем адрес ячейки в палитре (каждая ячейка - 2 байта)
    num32 palette_offset : index * 2
    num32 palette_address : 0x4A0000 + palette_offset

    ## Создаем указатель типа num16*, чтобы записать 2 байта
    num16* color_ptr : palette_address
    @color_ptr : col
)
```

*Пример: ярко-пурпурный цвет (max R, 0 G, max B) будет `0b111110000011111`.*

**Шаг 3: Рисование пикселя**
Для рисования пикселя нужно записать **индекс цвета** (от 0 до 255) в соответствующую ячейку видеопамяти.

```rust
## Функция для рисования одного пикселя
##- x, y: координаты пикселя
##- color_index: 8-битный номер цвета из палитры
box draw_pixel[num32 x, num32 y, char color_index] (
    ## Вычисляем смещение пикселя в линейной видеопамяти
    num32 offset : y * 640 + x
    
    ## Получаем итоговый адрес, прибавляя смещение к базовому адресу
    num32 pixel_address : 0x400000 + offset

    ## Создаем указатель типа char*, чтобы записать 1 байт (индекс)
    char* pixel_ptr : pixel_address
    @pixel_ptr : color_index
)
```

**Шаг 4: Обновление экрана**
После того как вы закончили рисовать кадр, необходимо вызвать прерывание, чтобы отобразить изменения на экране[^8].

```rust
## Функция для вызова прерывания обновления экрана
box video_flush[] (
    ## В BoxLang для вызова прерываний можно использовать kasm
    kasm["int $11"]
)
```


#### 1.3. Графические прерывания

Помимо `INT_VIDEO_FLUSH`, существуют прерывания для работы со спрайтами[^8]. Они используют регистры `ESI` и `EGI` для адресов.


| Прерывание | Номер | Регистры | Описание |
| :-- | :-- | :-- | :-- |
| `INT_VIDEO_FLUSH` | `0x11` | - | Отображает содержимое видеопамяти на экране. |
| `INT_VIDEO_CLEAR` | `0x12` | - | Очищает видеопамять (заливает цветом с индексом 0)[^3]. |
| `INT_PPU_DRAW` | `0x13` | `ESI`: адрес спрайта в памяти, `EGI`: адрес назначения в видеопамяти. | Рисует спрайт 8x8 пикселей. |

### 2. Звуковой процессор (SPU)

SPU имеет 4 канала и позволяет генерировать звуки с использованием ADSR-огибающей. Управление происходит через одно прерывание.

#### 2.1. Прерывание `INT_BEEP`

| Прерывание | Номер | Описание |
| :-- | :-- | :-- |
| `INT_BEEP` | `0x23` | Воспроизводит звук на одном из 4-х каналов[^8]. |

#### 2.2. Параметры для `INT_BEEP`

Перед вызовом прерывания `int $23` необходимо загрузить значения в три регистра[^6]:

* **`ESI` (num32): Частота звука** в Герцах. Например, `440` для ноты "Ля".
* **`EAX` (num32): Канал и громкость.**
    * **Старшие 4 бита:** номер канала (0-3).
    * **Младшие 4 бита:** громкость (0-15).
    * Пример: `0x1F` означает "канал 1, громкость 15".
* **`EDX` (num32): ADSR-огибающая.** 32-битное число, где каждый байт отвечает за длительность фазы в условных "тиках" (1 тик ≈ 8 мс).
    * **Байт 3 (самый старший):** Attack (Атака)
    * **Байт 2:** Decay (Спад)
    * **Байт 1:** Sustain (Задержка)
    * **Байт 0 (самый младший):** Release (Затухание)

**Пример в BoxLang:**

```rust
box play_sound[] (
    ## Готовим параметры
    num32 frequency : 440
    num32 volume_and_channel : 0x0F ## Канал 0, громкость 15
    ## A=10, D=20, S=50, R=10 тиков
    num32 adsr : 0x0A14320A

    ## Загружаем в регистры через ассемблерную вставку
    kasmf["mov %esi {}", frequency]
    kasmf["mov %eax {}", volume_and_channel]
    kasmf["mov %edx {}", adsr]

    ## Вызываем прерывание
    kasm["int $23"]
)
```


### 3. Общие системные прерывания

| Прерывание | Номер | Описание |
| :-- | :-- | :-- |
| `INT_EXIT` | `0x00` | Завершает программу. Код возврата берется из стека[^8]. |
| `INT_READ` | `0x01` | Читает один символ из стандартного ввода и помещает его в стек[^8]. |
| `INT_WRITE` | `0x02` | Печатает один символ из стека в стандартный вывод[^8]. |
| `INT_RAND` | `0x21` | Помещает случайное 32-битное число в регистр `EDX`[^8]. |
| `INT_WAIT` | `0x22` | Ожидает количество миллисекунд, указанное в регистре `EDX`[^8]. |
