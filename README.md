# BoxLang: Документация

BoxLang — это компилируемый, статически типизированный язык программирования, созданный для разработки под кастомную 32-битную архитектуру **GovnoCore32-20020**.

Ключевая особенность языка — независимость от BIOS и операционной системы. Компилятор генерирует ассемблерный код `kasm`, который может исполняться напрямую на процессоре, что дает полный контроль над оборудованием. Основная цель проекта — создание низкоуровневых библиотек, включая графическую библиотеку, по принципам схожую с OpenGL 1.0.

## 1. Основы синтаксиса

### Комментарии

Однострочные комментарии начинаются с `##`. Все, что следует за этим символом до конца строки, игнорируется компилятором.

```rust
## Это однострочный комментарий
num32 my_var : 10 ## Присваиваем значение переменной
```


### Типы данных

В BoxLang встроено несколько базовых типов данных, а также возможность создавать свои с помощью структур.


| Тип | Описание | Размер в памяти |
| :-- | :-- | :-- |
| `num32` | 32-битное целое число со знаком. | 4 байта |
| `num16` | 16-битное целое число со знаком. | 2 байта |
| `char` | 8-битный символ, хранится как ASCII-код. | 1 байт |
| `T*` | Указатель на данные типа `T`. | 4 байта |
| `имя_структуры` | Пользовательский тип данных. | Зависит от полей |

### Числовые литералы

BoxLang поддерживает запись чисел в нескольких системах счисления, что крайне полезно для низкоуровневой разработки.

* **Десятичные (Decimal):** Обычные числа. `10`, `42`, `123`.
* **Шестнадцатеричные (Hexadecimal):** Начинаются с префикса `0x`. `0xFF` (255), `0x4A0000` (адрес палитры).
* **Двоичные (Binary):** Начинаются с префикса `0b`. `0b1111` (15), `0b111110000011111` (цвет в формате RGB555).

```rust
num32 value1 : 255
num32 value2 : 0xFF    ## То же самое число 255
num32 value3 : 0b11111111 ## И снова 255
```


### Переменные

Переменные могут быть объявлены в глобальной области видимости (вне функций) или в локальной (внутри функций).

* **Объявление:** `тип имя_переменной`
* **Объявление с инициализацией:** `тип имя_переменной : значение`
* **Присваивание:** `имя_переменной : новое_значение`

```rust
## Глобальная переменная
num32 global_counter : 0

box _start[] (
    ## Локальная переменная
    num32 local_value

    ## Присваивание
    local_value : 42
)
```


### Массивы

Массивы — это наборы элементов одного типа с фиксированным размером. Индексация начинается с 0.

```rust
## Объявление локального массива из 10 целых чисел
num32 local_array[10]

## Запись в первый элемент массива
local_array[0] : 123

## Чтение из второго элемента
num32 value : local_array[^1]
```


#### Свойство `.length`

У каждого объявленного массива есть свойство `.length`, которое позволяет получить его размер на этапе компиляции. Это очень удобно для написания циклов, которые не выходят за границы массива.

```rust
num32 scores[^5]
num32 i : 0

while [i < scores.length] ( ## scores.length здесь равно 5
    scores[i] : i * 10
    i : i + 1
)
```


### Указатели

Указатели — сердце низкоуровневого программирования. Они хранят не значение, а **адрес** в памяти, где это значение находится.

* **Объявление указателя:** `тип* имя_указателя`
* **Оператор взятия адреса (`&`):** Возвращает адрес переменной в памяти.
* **Оператор разыменования (`@`):** Получает или изменяет значение, хранящееся *по адресу*, который записан в указателе.


#### Ключевая концепция: Тип указателя

Это самый важный аспект для понимания. Сам указатель, будь то `num32*`, `num16*` или `char*`, — это всегда **4-байтное число** (адрес). Тип, стоящий *перед звёздочкой* (`T` в `T*`), говорит компилятору не о размере самого указателя, а о том, **какого размера данные** находятся по этому адресу.

* Когда вы пишете `@my_num32_ptr : 10`, компилятор записывает **4 байта**.
* Когда вы пишете `@my_num16_ptr : 10`, компилятор записывает **2 байта**.
* Когда вы пишете `@my_char_ptr : 10`, компилятор записывает **1 байт**.

Это позволяет точно управлять памятью, что необходимо для работы с оборудованием.

```rust
## Записываем 2-байтное значение цвета в палитру по адресу 0x4A0000 + (1 * 2)
num16* palette_color : 0x4A0002
@palette_color : 0b111110000011111

## Записываем 1-байтный индекс цвета в видеопамять по адресу 0x400000 + 641
char* pixel : 0x400000 + 641
@pixel : 1
```


### Структуры (`struct`)

Структуры позволяют объединять несколько переменных разных типов в единый пользовательский тип. Это ключевой инструмент для организации сложных данных, например, для описания игровых объектов, аппаратных устройств или записей в файловой системе.

* **Объявление структуры:** `struct ИмяСтруктуры ( поле1 тип1, поле2 тип2, ... )`
* **Создание экземпляра:** `ИмяСтруктуры имя_переменной`
* **Доступ к полям:** `имя_переменной.имя_поля`

```rust
## Объявляем новый тип для представления 2D-вектора
struct Vec2 (
    num32 x
    num32 y
)

box _start[] (
    ## Создаем переменную нашего нового типа
    Vec2 position

    ## Присваиваем значения полям структуры
    position.x : 100
    position.y : 250

    ## Используем значения из полей
    num32 new_x : position.x + 50
)
```


## 2. Функции

Функции являются основными строительными блоками программы. Программа всегда начинает выполнение с функции `_start`.

* **Объявление:** `box имя_функции[параметры] ( тело_функции )`
* **Вызов:** `open имя_функции[аргументы]`
* **Возврат значения:** `ret значение`

```rust
## Функция принимает два числа и возвращает их сумму
box add_numbers[num32 a, num32 b] (
    ret a + b
)

## Основная функция
box _start[] (
    ## Вызываем функцию и сохраняем результат
    num32 result : open add_numbers[10, 5] ## result станет равен 15
)
```


## 3. Управляющие конструкции

### `if-else`

Условная конструкция для ветвления логики.

```rust
num32 a : 10
if [a < 20] (
    open print["a is less than 20$"]
) else (
    open print["a is NOT less than 20$"]
)
```


### `while`

Цикл, который выполняется, пока истинно его условие.

```rust
num32 i : 0
while [i < 5] (
    open print_num[i]
    i : i + 1
)
```


### `for`

Цикл `for` — более удобная форма для итераций, которая объединяет инициализацию, условие и шаг в одной строке.

**Синтаксис:** `for [инициализация; условие; инкремент] ( тело_цикла )`

* **Инициализация:** Выполняется один раз перед началом цикла. Обычно здесь объявляется переменная-счетчик.
* **Условие:** Проверяется перед каждой итерацией. Если оно ложно, цикл завершается.
* **Инкремент:** Выполняется в конце каждой итерации. Обычно здесь изменяется счетчик.

```rust
## Выводим числа от 0 до 4
for [num32 i : 0; i < 5; i : i + 1] (
    open print_num[i]
    open print["$"]
)
```


### `match-case`

Позволяет сравнить выражение с несколькими константными значениями. Блок `default` выполняется, если ни один из `case` не подошёл.

```rust
num32 x : 2
match [x] (
    case [1] (
        open print["one$"]
    )
    case [2] (
        open print["two$"]  ## Этот блок выполнится
    )
    default (
        open print["other$"]
    )
)
```


## 4. Операторы

| Категория | Оператор | Описание |
| :-- | :-- | :-- |
| **Арифметические** | `+`, `-`, `*`, `/` | Сложение, вычитание, умножение, деление. |
| **Сравнения** | `==`, `!=`, `<`, `>`, `<=`, `>=` | Равно, не равно, меньше, больше и т.д. |
| **Присваивание** | `:` | Присваивает значение переменной. |
| **Доступ к полям/свойствам** | `.` | Используется для доступа к полям структур и свойствам массивов (`.length`). |
| **Указатели** | `&`, `@` | Взятие адреса и разыменование. |

## 5. Ассемблерные вставки (`kasm` и `kasmf`)

Для полного контроля над железом BoxLang предоставляет директивы для прямой вставки ассемблерного кода `kasm`.

### `kasm`

Эта директива вставляет статическую, неизменяемую ассемблерную инструкцию прямо в код.

**Синтаксис:** `kasm["инструкция операнд1 операнд2"]`

**Важно:** Ассемблер `kasm` разделяет операнды **пробелами**, а не запятыми.

```rust
## Вызываем системное прерывание для обновления экрана
kasm["int $11"]
```


### `kasmf`

Это форматируемая версия `kasm`, которая позволяет подставлять в ассемблерную строку значения переменных или выражений из BoxLang.

**Синтаксис:** `kasmf["форматная_строка {}", arg1, ...]`

**Как это работает:**

1. Компилятор вычисляет значение каждого аргумента (`arg1` и т.д.).
2. Результат вычисления помещается в безопасный временный регистр (из диапазона `%e8` - `%e31`).
3. Имя этого временного регистра подставляется в строку вместо `{}`.
Этот механизм гарантирует, что важные рабочие регистры (`%eax`, `%ebx` и т.д.) не будут случайно испорчены.
```rust
box play_sound[num32 frequency] (
    ## Готовим параметры для прерывания звука
    num32 volume_and_channel : 0x0F ## Канал 0, громкость 15
    num32 adsr : 0x0A14320A

    ## Загружаем значения переменных в регистры
    kasmf["mov %esi {}", frequency]
    kasmf["mov %eax {}", volume_and_channel]
    kasmf["mov %edx {}", adsr]

    ## Вызываем прерывание
    kasm["int $23"]
)
```


## 6. Препроцессор и стандартная библиотека

### Директива `@incl`

Позволяет включать содержимое других файлов в текущий файл перед компиляцией.

* `@incl <stdprint>`: Включение системной библиотеки. Поиск ведется в стандартной папке `std/`. Можно не указывать расширение файла.
* `@incl "my_functions.box"`: Включение пользовательского файла. Поиск ведется относительно текущего файла.


### Стандартные функции

Базовые функции предоставляются стандартными библиотеками, которые необходимо подключать через `@incl`.

* **Библиотека `stdprint.asm` (Вывод текста):**
    * `open init_text_mode[]`: Инициализирует экран в текстовый режим 80x60.
    * `open clear_screen[]`: Очищает экран в текущем режиме.
    * `open print["string"]`: Выводит строку в текстовом режиме. Символ `$` интерпретируется как перенос строки.
    * `open print_num[number]`: Выводит на экран число типа `num32`.
* **Библиотека `stdlib.box` (Более новая stdio):**
    * `open exit[code]`: Завершает программу с указанным кодом.
    * `open sum_n32[&array_ptr]`: Суммирует элементы массива `num32`.
    * `open trapf[]`: Вызывает отладочную ловушку для остановки эмулятора и проверки состояния.
* **Библиотека `stdio.asm` (Поддержка прекращена):**
    * `open VIDEO_FLUSH[]`: Принудительно обновляет экран, чтобы показать изменения в видеопамяти.
    * `open trapf[]`: Вызывает отладочную ловушку для остановки эмулятора и проверки состояния.
    * `open exit[code]`: Завершает выполнение программы с указанным кодом.


## 7. Компиляция и запуск

Для компиляции файла BoxLang используется `main.py`.

**Команда:**

```bash
python boxlang/main.py <исходный_файл.box> [выходной_файл.asm]
```

**Пример:**

```bash
python boxlang/main.py code/test_pointers.box output.asm
```

Эта команда скомпилирует `test_pointers.box` и создаст ассемблерный файл `output.asm`, готовый для ассемблера `kasm`.

## 8. Дополнительные примеры

### Пример 1: "Hello World"

```rust
## Подключаем стандартные библиотеки для вывода на экран
@incl <stdprint> 
@incl <stdio>

## Каждая программа должна иметь функцию _start
box _start[] (
    ## Инициализируем видеорежим
    open init_text_mode[]
    open clear_screen[]

    ## Выводим строку. '$' - это символ новой строки.
    open print["Hello, World!$"]

    ## Вызываем отладочную ловушку, чтобы увидеть результат.
    open trapf[]
)
```


### Пример 2: Использование цикла `for` и `.length`

Этот пример суммирует элементы массива, используя цикл `for` и свойство `.length`.

```rust
@incl <stdprint>
@incl <stdio>

box _start[] (
    open init_text_mode[]
    open clear_screen[]

    num32 data[5]
    data[0]: 10
    data[1]: 20
    data[2]: 30
    data[3]: 40
    data[4]: 50

    num32 sum : 0
    for [num32 i : 0; i < data.length; i : i + 1] (
        sum : sum + data[i]
    )

    open print["Sum of array elements: $"]
    open print_num[sum] ## Выведет 150
    open print["$"]
    
    open trapf[]
)
```


### Пример 3: Использование структур

Этот пример показывает, как объявить структуру `Player`, создать ее экземпляр и работать с ее полями.

```rust
@incl <stdprint>
@incl <stdio>

## Объявляем структуру для игрока
struct Player (
    num32 x
    num32 y
    num16 health
)

box _start[] (
    open init_text_mode[]
    open clear_screen[]

    ## Создаем локальную переменную типа Player
    Player p1

    ## Инициализируем ее поля
    p1.x : 200
    p1.y : 150
    p1.health : 100

    open print["Player position: ("]
    open print_num[p1.x]
    open print[", "]
    open print_num[p1.y]
    open print[") $"]

    open print["Player health: "]
    open print_num[p1.health]
    open print["$"]

    ## Игрок получает урон
    p1.health : p1.health - 25
    open print["Health after damage: "]
    open print_num[p1.health] ## Выведет 75
    open print["$"]

    open trapf[]
)
```
