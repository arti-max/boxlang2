# BoxLang: Подробная Документация

## Оглавление

1. [Что такое BoxLang?](#what_is_boxlang)
2. [Синтаксис: базовые конструкции](#syntax_basics)
    - [Комментарии](#comments)
    - [Типы данных](#types)
    - [Переменные и область видимости](#variables)
    - [Массивы и свойство `.length`](#arrays)
    - [Указатели: ключ к памяти (`&` и `@`)](#pointers)
    - [Структуры (`struct`): свои типы данных](#structs)
3. [Функции: `box`, `open`, `ret` и стек](#functions)
4. [Управляющие конструкции](#control_structures)
    - [`if-else`](#if)
    - [`while`, `for`](#loops)
    - [`match-case`](#match)
5. [Операторы: от арифметики до битов](#operators)
6. [Тип `float`: числа с плавающей точкой](#float_deep_dive)
    - [Особенности `float`](#float_features)
    - [Явное преобразование: `to_float()` и `to_int()`](#float_casting)
7. [Ассемблерные вставки: `kasm` и `kasmf`](#inline_asm)
8. [Препроцессор и стандартная библиотека (`@incl`)](#preprocessor_incl)
9. [Процесс компиляции и запуска](#compilation)
10. [Примеры и лучшие практики](#examples)

<a name="what_is_boxlang"></a>

## 1. Что такое BoxLang?

BoxLang — это компилируемый, статически типизированный язык программирования, созданный специально для низкоуровневой разработки под архитектуру **GovnoCore32-20020**. Он предоставляет удобный синтаксис, но компилируется в ассемблерные инструкции, давая вам полный контроль над памятью, регистрами и периферийными устройствами.

**Главная цель** — предоставить инструмент для создания сложного системного ПО (ОС, BIOS, драйверы) и игр, не увязая в чисто ассемблерном коде, но и не теряя контроля над железом.

<a name="syntax_basics"></a>

## 2. Синтаксис: базовые конструкции

<a name="comments"></a>

### Комментарии

Однострочные комментарии начинаются с `##`.

```rust
## Это однострочный комментарий.
```

<a name="types"></a>

### Типы данных

| Тип | Назначение | Размер | Пример |
| :-- | :-- | --: | :-- |
| `num32` | 32-битное целое со знаком | 4Б | `num32 x : 123` |
| `num16` | 16-битное целое со знаком | 2Б | `num16 c : 40` |
| `char` | 8-битный символ/число | 1Б | `char a : 'A'` |
| `float` | 32-битное число с плавающей точкой | 4Б | `float pi : 3.14` |
| `T*` | 32-битный указатель на данные типа `T` | 4Б | `num32* ptr` |

<a name="variables"></a>

### Переменные и область видимости

- **Объявление:** `тип имя : значение`
- **Присваивание:** `имя : новое_значение`

В BoxLang есть две области видимости:

- **Глобальные переменные:** Объявляются вне любых функций. Они существуют в течение всего времени работы программы и хранятся в специальной секции данных. Доступны из любой функции.
- **Локальные переменные:** Объявляются внутри функции (`box`). Они создаются в момент вызова функции на **стеке** и уничтожаются при выходе из нее. Это значит, что локальная переменная одной функции не видна в другой.

```rust
num32 global_counter : 0 ## Глобальная переменная

box _start[] (
    char local_char : 'X' ## Локальная переменная, видна только в _start
    global_counter : global_counter + 1
)
```

<a name="arrays"></a>

### Массивы и свойство `.length`

Массив — это непрерывный блок памяти для хранения нескольких элементов одного типа.

- **Объявление:** `тип имя[размер]`
- **Доступ к элементу:** `имя_массива[индекс]` (индексация с 0).

**Под капотом:** объявление `num32 data[10]` — это команда компилятору выделить `10 * 4 = 40` байт памяти. Доступ `data[2]` превращается в `*(базовый_адрес_data + 2 * 4)`.

**Свойство `.length`** — это удобная возможность получить размер массива на этапе компиляции.

```rust
char message[12] : "Hello, world"
for [num32 i : 0; i < message.length; i : i+1] (
    open print_char[message[i]]
)
```

<a name="pointers"></a>

### Указатели: ключ к памяти (`&` и `@`)

Указатель — это переменная, которая хранит не само значение, а **адрес в памяти**, где это значение лежит. Это самый мощный инструмент для низкоуровневой работы.

- **Аналогия:** Переменная — это коробка с вещью. Указатель — это записка, на которой написан номер склада и полки, где стоит эта коробка.
- **Оператор `&` (взятие адреса):** "На какой полке стоит эта коробка?"

```rust
num32 my_var : 100
num32* ptr : &my_var ## ptr теперь хранит адрес переменной my_var
```

- **Оператор `@` (разыменование):** "Пойти по адресу из записки и посмотреть, что в коробке".

```rust
num32 value : @ptr ## value станет равно 100
@ptr : 200         ## значение в my_var теперь 200
```

- **Тип указателя (`T*`):** Тип *перед звёздочкой* (`num32*`, `char*`) говорит компилятору, **какого размера коробка** находится по этому адресу. Сам указатель — это всегда 4-байтный адрес.
    - `@num32_ptr` — прочитать/записать 4 байта.
    - `@char_ptr` — прочитать/записать 1 байт.

<a name="structs"></a>

### Структуры (`struct`): свои типы данных

Структуры позволяют объединять переменные разных типов в один новый, пользовательский тип. Это необходимо для организации сложных данных (координаты, параметры игрока, записи в файле).

- **Объявление:** `struct Имя ( поле1 тип1, поле2 тип2 )`
- **Доступ к полям:** `переменная.поле`

**Под капотом:** Поля структуры просто лежат в памяти друг за другом. Компилятор сам рассчитывает смещения. `player.health` превращается в `*(адрес_player + смещение_поля_health)`.

```rust
struct Player (
    num32 x, num32 y
    num16 health
)
Player p1
p1.x : 50
p1.health : 100
```

<a name="functions"></a>

## 3. Функции: `box`, `open`, `ret` и стек

Функции — это основа структурирования кода. Программа всегда начинается с функции `_start`.

- **`box` (Объявление):** Создает "чертеж" функции.
- **`open` (Вызов):** Запускает функцию в работу.
- **`ret` (Возврат):** Завершает функцию и возвращает результат.

**Как это работает (Концепция Стека Вызовов):**
Стек — это область памяти, работающая по принципу "последний вошел — первый вышел".

1. **`open my_func[10, 20]`:**
    - Аргументы `20`, а затем `10` кладутся на стек.
    - Адрес возврата (место в коде, куда нужно вернуться после `my_func`) кладется на стек.
    - Процессор "прыгает" на начало кода `my_func`.
2. **Внутри `my_func`:**
    - Функция выделяет на стеке место под свои локальные переменные.
    - Она знает, где на стеке лежат её аргументы, и работает с ними.
3. **`ret result`:**
    - Результат `result` кладется в специальный регистр (`%eax`).
    - Локальные переменные "уничтожаются" (место на стеке освобождается).
    - Адрес возврата снимается со стека, и процессор "прыгает" обратно.
```rust
box multiply[num32 a, num32 b] (
    ret a * b
)
box _start[] (
    num32 product : open multiply[5, 10] ## product станет равен 50
)
```

<a name="control_structures"></a>

## 4. Управляющие конструкции

<a name="if"></a>

### `if-else`

Ветвление логики. Блок `else` необязателен. `else if` тоже поддерживается.

```rust
if [score > 100] (
    open printf["You win!\n"]
) else (
    open printf["Keep trying...\n"]
)
```

<a name="loops"></a>

### `while` и `for`

**`while`** выполняет блок кода, пока условие истинно.

```rust
num32 i : 0
while [i < 10] ( i : i + 1 )
```

**`for`** — более удобная форма `while` для итераций.
`for [инициализация; условие; шаг] ( тело )`

```rust
for [num32 i : 0; i < 10; i : i + 1] (
    open print_num[i]
)
```

<a name="match"></a>

### `match-case`

Удобная замена множеству `if-else`, если нужно сравнить одну переменную с несколькими константами.

```rust
match [key_code] (
    case ['w'] ( direction : 0 )
    case ['s'] ( direction : 1 )
    default ( ## Необязательный блок
        open printf["Wrong key!\n"]
    )
)
```

<a name="operators"></a>

## 5. Операторы: от арифметики до битов

| Категория | Оператор | Описание |
| :-- | :-- | :-- |
| **Арифметические** | `+ - * / %` | Сложение, вычитание, умножение, целочисленное деление, остаток. |
| **Сравнения** | `== != < > <= >=` | Равно, не равно, меньше, больше и т.д. |
| **Логические** | `&&` (И), `\|\|` (ИЛИ) | Используются в условиях: `if [a > 0 && b > 0]` |
| **Побитовые** | `& | ^ << >>` | Побитовое И, ИЛИ, XOR, сдвиги влево и вправо. Критически важны для работы с оборудованием, флагами и цветами. |

<a name="float_deep_dive"></a>

## 6. Тип `float`: числа с плавающей точкой

<a name="float_features"></a>

### Особенности `float`

BoxLang полностью поддерживает 32-битные числа с плавающей точкой (аналог `float` в C), используя FPU (Floating-Point Unit) эмулятора.

- **Внутреннее представление:** Внутри `float` хранится не как целое число, а в специальном формате **IEEE 754**. Это значит, что битовое представление `float` `2.0` и `num32` `2` — **совершенно разное**. Именно поэтому прямое смешивание типов запрещено.
- **Неточность:** Как и в большинстве языков, `float` не может точно представить все десятичные дроби. `0.1 + 0.2` может не быть в точности равно `0.3`. Это нормально и является особенностью формата.
- **Операции:** Для `float` доступны все стандартные арифметические (`+`, `-`, `*`, `/`) и операции сравнения (`==`, `<`, `>` и т.д.). Компилятор автоматически использует для них специальные FPU-инструкции (`addf32`, `subf32`, и т.д.).

<a name="float_casting"></a>

### Явное преобразование: `to_float()` и `to_int()`

Смешивать `float` и целые числа в одной операции **запрещено** для избежания случайных ошибок и потери производительности. Для преобразования существуют встроенные функции:

- `open to_float[целое_число]`: Преобразует `num32`/`num16`/`char` в `float`.
- `open to_int[float_число]`: Преобразует `float` в `num32`, **отбрасывая** дробную часть (не округляя).

```rust
num32 health : 100
float damage : 15.5

## ОШИБКА КОМПИЛЯЦИИ! Нельзя смешивать типы.
## health : health - damage

## ПРАВИЛЬНО:
health : health - open to_int[damage] ## health станет 85

float mana_cost : open to_float[health] * 0.1 ## mana_cost станет 10.0
```

<a name="inline_asm"></a>

## 7. Ассемблерные вставки: `kasm` и `kasmf`

Для полного контроля над железом существуют директивы для вставки ассемблерного кода `kasm`.

- **`kasm["инструкция"]`:** Вставляет статическую ассемблерную инструкцию. Идеально для простых вызовов вроде `trap` или `int $11`.
- **`kasmf["формат {}", arg]`:** Форматируемая вставка. Позволяет подставлять значения переменных или выражений BoxLang в ассемблерный код. Компилятор сам вычисляет аргумент, помещает его в безопасный временный регистр (например, `%e8`-`%e31`) и подставляет имя этого регистра вместо `{}`. Это самый безопасный способ передать динамические данные в ассемблер.

<a name="preprocessor_incl"></a>

## 8. Препроцессор и стандартная библиотека (`@incl`)

Директива `@incl` позволяет включать код из других файлов.

- `@incl <stdlib>`: Включает файл из стандартной папки (`boxlang/std/`).
- `@incl "my_lib.box"`: Включает файл из той же папки, где лежит текущий файл.

Это позволяет разбивать большие проекты на модули и создавать свои библиотеки.

<a name="compilation"></a>

## 9. Процесс компиляции и запуска

1. **Компиляция:** `python boxlang/main.py my_program.box my_program.asm`
    - Компилятор BoxLang читает ваш `.box` файл, обрабатывает `@incl` и превращает код в ассемблерный текст для `kasm`.
2. **Ассемблирование:** `python boxlang/main.py my_program.box my_program.asm -kasm`
    - Ассемблер `kasm` читает сгенерированный `.asm` файл и превращает текстовые инструкции в байткод — двоичный файл, который "понимает" процессор.
3. **Запуск:** `gc32-20020 my_program.bin`
    - Эмулятор GovnoCore32-20020 загружает ваш `.bin` файл в память и начинает его выполнение.
4. **Архитектура x86:** `python boxlang.main.py my_program.box my_program.asm -x86`
    - Конвертер kasm в nasm читает сгенерированный kasm код, и на его основе создаёт nasm код в файле `.nasm.asm`, который затем нужно скомпилировать с помощью компилятора nasm

<a name="examples"></a>

## 10. Примеры и лучшие практики

- Всегда начинайте программу с `box _start[]`.
- Используйте `printf` из `stdlib` для удобного форматированного вывода.
- Разбивайте код на маленькие, понятные функции.
- Для низкоуровневых операций, требующих конкретных регистров, используйте `kasmf`.
- Помните о явном приведении типов при работе с `float`.

**Пример с `float` и `printf`:**

```rust
@incl <stdlib>

box _start[] (
    open init_text_mode[]
    
    float pi : 3.141
    num32 r : 5
    
    float circle_len : 2.0 * pi * open to_float[r]
    
    open printf["Radius: %i, Length: %f\n", r, circle_len]
    open trapf[]
)
```

