# BoxLang: Подробная Документация

## Оглавление

1. [Что такое BoxLang?](#what_is_boxlang)
2. [Синтаксис: базовые конструкции](#syntax_basics)
    - [Комментарии](#comments)
    - [Типы данных](#types)
    - [Числовые литералы и размеры типов](#literals)
    - [Переменные и присваивания](#variables)
    - [Массивы и свойство `.length`](#arrays)
    - [Указатели и адресация](#pointers)
    - [Структуры (`struct`)](#structs)
3. [Функции и вызовы](#functions)
4. [Управляющие конструкции](#control_structures)
    - [if-else](#if)
    - [while, for](#loops)
    - [match-case](#match)
5. [Арифметические и прочие операторы](#operators)
6. [Ассемблерные вставки: `kasm` и `kasmf`](#inline_asm)
    - [`kasm` — статический ассmbler](#kasm)
    - [`kasmf` — форматируемая вставка ассемблера (с `{}`)](#kasmf)
    - [Что делает фигурная скобка `{}`](#curly_brackets)
    - [Примеры использования вставок](#examples_inlineasm)
7. [Расширенные арифметические операции, тип float и особенности платформы](#advanced_arith_float)
8. [Препроцессор, стандартная библиотека и @incl](#preprocessor_incl)
9. [Компиляция и запуск](#compilation)
10. [Расширенные приёмы, хорошие паттерны и лучшие практики](#best_practices)
11. [Примеры](#examples)
12. [Часто задаваемые вопросы (FAQ)](#faq)

<a name="what_is_boxlang"></a>

## 1. Что такое BoxLang?

BoxLang — это компилируемый, статически типизированный язык программирования, созданный специально для низкоуровнего программирования под архитектуру **GovnoCore32-20020**. Он предоставляет приятный синтаксис, но компилируется в ассемблерные инструкции с возможностью напрямую управлять памятью, регистрами, видео и работой устройства.

**Главные цели:**

- Лёгкая низкоуровневая разработка: можно писать драйверы, BIOS, операционные системы, игры, графические движки и многое другое.
- Гибкая работа с памятью (указатели, массивы, ручное управление).
- Встроенные вставки ассемблера для абсолютного контроля над машиной.
- Простая интеграция с автогенерируемыми asm-фрагментами и стандартной библиотекой.

<a name="syntax_basics"></a>

## 2. Синтаксис: базовые конструкции

<a name="comments"></a>

### Комментарии

- **Одинарный комментарий:** `## комментарий`
- Всё, что после `##` до конца строки, игнорируется компилятором.

```rust
## Это поясняющий комментарий. Не влияет на код.
```

<a name="types"></a>

### Типы данных и переменные

| Тип | Назначение | Размер | Пример |
| :-- | :-- | --: | :-- |
| `num32` | 32-битное целое | 4Б | `num32 x : 123` |
| `num16` | 16-битное целое | 2Б | `num16 c : 40` |
| `char` | 8-битный символ/число | 1Б | `char a : 65` |
| `float` | 32-битное число (float) | 4Б | `float pi : 3.14` |
| `имя_структуры` | Структурный пользовательский тип | — | `Vec2 point` |
| `T*` | Указатель на тип `T` | 4Б | `num32* ptr` |

<a name="literals"></a>

### Числовые литералы и размеры

* Десятичные: `42`
* Шестнадцатеричные: `0xFF`, `0x4A0000`
* Двоичные: `0b1111`
* Символьные: `'A'`, `'$', '\n'`, `'x'`
* Числа с плавающей точкой: `3.1415`, `-10.0`
* При объявлении строка `"hello"` всегда считается массивом символов (см. ниже).


#### Примеры:

```rust
num32 a : 100
num16 color : 0x4A3F
char code : 65  ## это 'A'
float temp : -36.7
```

<a name="variables"></a>

### Переменные и присваивание

- **Объявление:** `тип имя`
- **С инициализацией:** `тип имя : значение`
- **Присваивание:** `имя : новое_значение`
- Глобальные переменные пишутся вне функций (box).


#### Пример:

```rust
num32 counter : 0
char sym : 'C'
box _start[] (
    counter : counter + 1
    sym : sym + 2
)
```

<a name="arrays"></a>

### Массивы и свойство `.length`

- **Объявление массива:** `тип имя[размер]`
- Индексация с 0: `arr`, `arr[^5]`
- `.length` — свойство массивов, возвращающее их размер (константа на этапе компиляции!).

```rust
num32 data[^10]
data[^0]: 45
data[^9]: 77
## Получить размер массива:
num32 n : data.length ## n = 10
```

**Совет:** Используйте `.length` в циклах, чтобы легко писать универсальные алгоритмы!

<a name="pointers"></a>

### Указатели и адресация

BoxLang позволяет работать с памятью напрямую. Это делается через указатели.

- **Объявление указателя:** `тип* имя`
- **Взятие адреса:** `&имя`
- **Разыменование (чтение или запись):** `@указатель`

**Важно:** Тип указателя (`num32*`, `num16*`, `char*`, `float*`) влияет только на то, сколько байт будет читаться/писаться по этому адресу при операции `@`.

```rust
num32* ptr : 0x400000
@ptr : 123456      ## По адресу 0x400000 кладёт 4 байта
char* p : 0x400000
@p : 0x42          ## Кладёт 1 байт по тому же адресу
@p : @p + 1        ## Инкремент по адресу
```


---

<a name="structs"></a>

### Структуры (`struct`)

Позволяют группировать данные разных типов.

```rust
struct Vec2 (
    num32 x
    num32 y
)

Vec2 pos
pos.x : 5
pos.y : 7
```


---

<a name="functions"></a>

## 3. Функции и вызовы

- **Объявление функции:** `box имя[параметры] ( тело )`
- **Вызов:** `open имя[аргументы]`
- **Возврат значения:** `ret x`

```rust
box add[num32 a, num32 b] (
    ret a + b
)
box _start[] (
    num32 sum : open add[10, 15]  ## sum == 25
)
```


---

<a name="control_structures"></a>

## 4. Управляющие конструкции

<a name="if"></a>

### Условный оператор if-else

```rust
if [val < 5] (
    ## ...
) else (
    ## ...
)
```

<a name="loops"></a>

### Циклы while и for

**while**:

```rust
while [cond] ( ... )
```

**for** (ещё проще, чем в C!):

```rust
for [num32 i : 0; i < arr.length; i : i+1] ( ... )
```

<a name="match"></a>

### Выборка значений — match/case

```rust
match [expr] (
    case [1] ( ... )
    case [2] ( ... )
    default ( ... )
)
```


---

<a name="operators"></a>

## 5. Операторы

| Категория | Оператор | Назначение/пример |
| :-- | :-- | :-- |
| Арифметика | `+ - * / % //` | int/float +, -, *, /, %, целочисл.// |
| Логика | `== != < > <= >=` | сравнения |
| Присваивание | `:` | `a : 42` |
| Полевой доступ | `.` | `x.y`, `array.length` |
| Память/указатели | `&`, `@` | адрес и разыменование |
| Побитовые | `| ^ & << >>` | bitwise И, ИЛИ, XOR, сдвиги |
| Каскады | `open`, `ret`, `box`, `struct` | вызовы, возвраты, объявления |

---

<a name="inline_asm"></a>

## 6. Ассемблерные вставки (`kasm` и `kasmf`)

BoxLang поддерживает простую вставку машинно-независимого ассемблера, который превращается в инструкции GovnoCore.

<a name="kasm"></a>

### `kasm` — базовая вставка

- Позволяет вставить текст asm прямо как есть.
- Для коротких сервисных инструкций, вроде `int $code`, nop, mov и т.д.
- **! Аргументы нельзя вставлять динамически, только «жёсткий» код.**

**Пример**

```rust
kasm["mov %eax 5"]
kasm["int $11"]
```

<a name="kasmf"></a>

### ⚡️ `kasmf` — вставка с подстановкой аргументов (`{}`)

**kasmf** — главное оружие для динамики!

#### Зачем нужен kasmf?

- Позволяет подставлять **значения переменных/выражений** BoxLang прямо в ассемблерную строку — при этом компилятор возьмёт переменную, запишет её во временный (неиспользуемый) регистр и **заменит** в тексте на имя этого регистра.
- Таких подстановок `{}` может быть несколько.


#### Синтаксис:

```rust
kasmf["mov %reg {}", x]
```

- Внутри строки для ассемблера пишешь **без изменений** (как бы руками написал kasm).
- Вместо значения, которое должно меняться — подставляешь `{}`.
- После строки указываешь список переменных или выражений: они сопоставляются с каждым `{}` слева направо.


#### Важно!

- Каждый аргумент подставляется в ОТДЕЛЬНЫЙ временный регистр (например, `%e8`, `%e9` ... `%e31`), которые **никогда** не пересекаются с системными (`%eax`, `%ebx`, ...)!
- Даже если в подстановке сложное выражение (`kasmf["add %eax, {}", a + b * 3]`), оно будет вычислено заранее и результат попадёт в регистр, который затем подставится.
- Если подстановок больше, чем временных регистров — компилятор выдаст ошибку!

<a name="curly_brackets"></a>

#### Как устроена подстановка фигурной скобки `{}`

- По порядку перебирает аргументы (число, указатель, выражение).
- Для КАЖДОГО:
    - Генерирует (невидимым для программиста образом!) ассемблер:
        - вычисляет и кладёт значение в temp-регистр;
        - подменяет `{}` на имя этого temp-формата (обычно это `%e8`, `%e9` ... `%e31`);
- Строка после такой обработки становится **настоящей ASM-инструкцией**, где все значения уже прошли через выражения на BoxLang.

**Выгода:** ты никогда не ломаешь состояние ключевых регистров (например, %eax не портится), потому что kasmf сам обеспечивает безопасность.

<a name="examples_inlineasm"></a>

#### Примеры (чем kasmf отличается от kasm):

```rust
box play_sound[num32 freq] (
    ## Готовим значения
    num32 vol : 0x13     ## громкость
    kasmf["mov %esi {}", freq]
    kasmf["mov %eax {}", vol]
    kasm["int $23"]
)
```

- В этом примере
    - `freq` компилятор кладёт во временный регистр (например, `%e8`), и строка превращается во что-то вроде `"mov %esi %e8"`
    - vol → в `%e9`.
    - Вся логика передачи значений на ассемблерные инструкции становится очень наглядной ЕДИНОЙ строкой!

<a name="advanced_arith_float"></a>

## 7. Расширенные арифметические операции и работа с float

### Арифметика

- Можно прямо использовать: `+ - * / % //` с целыми и (НОВОЕ!) с float-значениями (если поддержка уже реализована в компиляторе).


#### Особенности:

- `/` — обычное целочисленное деление (остаток всегда теряется).
- `//` — всегда целочисленный результат (если используешь нецелый тип, каст произойдёт автоматически).


### Поддержка float

- Тип `float` реализован как 32-битное число с плавающей точкой одинарной точности (аналог C `float`), благодаря отдельному FPU GovnoCore.
- К float можно применять: `+`, `-`, `*`, `/`, возведение в степень `**`, сравнения `==`, `<`, `>` и др.
- Компилятор сам разбирает по типу: если хотя бы один аргумент в выражении — float, вся арифметика делается через FPU-инструкции эмулятора (см. коды в `fpu.h`).


#### Пример:

```rust
float a : 1.5
float b : 2.5
float c : a + b * 2.0
```

*Для приведения типов используют встроенные инструкции преобразования:*

```rust
float f : 1
num32 i : 3.3    ## ошибка! (ожидает int), нужен явный cast (будет доступен позднее)
```


### Побитовые и логические операторы

- Доступно: `&` (AND), `|` (OR), `^` (XOR), `<<`, `>>`.
- Операции сравнения можно комбинировать через `&&`, `||`.


### Новые возможности компилятора

- `.length` для массивов.
- Обработка `*` как pointer, а не просто оператор умножения.
- Расширенный синтаксис для функций с переменным числом аргументов (`box func[char* fmt, ...]`).
- Свойство `.length` для массивов.
- Гибкая поддержка структур с любым списком полей.
- Расширенная арифметика, auto-upcast в функцию, extended pointer dereference.
- Побитовые (`&`, `|`, `^`, `<<`, `>>`) работают не только для num32, num16, но и для char (как байт)!

<a name="preprocessor_incl"></a>

## 8. Препроцессор и директива `@incl`

@incl `<stdlib>` — подключает библиотеку из стандартной папки, например, `<stdprint>`, `<stdlib>` и т.д.
@incl "custom.box" — подключает файл пользователя из текущей директории.

Все include-файлы проходят через препроцессор — это значит, что можно разносить свой проект на много файлов и всё соберётся самó.

<a name="compilation"></a>

## 9. Компиляция и запуск

1. Скомпилируй исходник в ассемблер:

```bash
python boxlang/main.py prog.box out.asm
```

2. Собери байткод через kasm:

```bash
python kasm.py out.asm out.bin
```

3. Запусти в эмуляторе:

```bash
gc32-20020 out.bin
```


<a name="best_practices"></a>

## 10. Лучшие паттерны и советы (рекомендуется к использованию)

- Всегда пиши main-функцию как `box _start[] ( ... )` — эмулятор ожидает её при запуске.
- Используй временные регистры только через kasmf!
- Для сложных операций с видеопамятью, указателями, массивами используйте kasmf, чтобы не писать низкоуровневый asm-сопроводительный код.
- Никогда не пиши напрямую `mov %eax {}` — используй kasmf, который сам подставит нужный временный регистр!
- Испытывай свой код на простых программах локально, прежде чем подключать сложные библиотеки.

<a name="examples"></a>

## 11. Примеры

**Минималка: Вывести число**

```rust
@incl <stdprint>
box _start[] (
    open init_text_mode[]
    open clear_screen[]
    open print["Number: $"]
    open print_num[^42]
    open trapf[]
)
```

**Работа с kasmf**

```rust
num32 x : 314
kasmf["mov %eax {}", x]           ## x загружается во временный регистр, потом mov к %eax
kasm["int $11"]                   ## простой вызов
```

**Строка как массив**

```rust
char hello[^6] : "Hello"
hello[^0] : 'H'
## hello.length == 6
```

**Функция с указателями**

```rust
box fill_mem[num32* ptr, num32 value, num32 len] (
    for [num32 i : 0; i < len; i : i + 1] (
        @(ptr + i * 4) : value
    )
)
```

<a name="faq"></a>

## 12. Часто задаваемые вопросы (FAQ)

### — Чем отличается kasm от kasmf?

- **kasm** — жестко вставляет одну или несколько инструкций без подстановок. Используй, если код полностью статичен.
- **kasmf** — магически позволяет подставлять значения аргументов из BoxLang в asm, аккуратно запихивая их в временные регистры и **подставляя эти регистры** вместо `{}`.


### — Что делают фигурные скобки `{}` в kasmf?

Это "место для подстановки" значений! Каждый `{}` — это переменная или выражение, вычисленное в temp-регистр, который подставится вместо фигурной скобки в строке ассемблера.

### — Зачем вообще временные регистры в kasmf?

Чтобы не перезаписывать %eax, %ebx, не тратить лишних mov-ов вручную, и не делать ошибок с перепутыванием регистров. Это как безопасный аналог шаблонов/printf, только для ассемблера!

### — Можно ли делать несколько kasmf подряд?

Конечно! Просто помни: каждый аргумент — новый временный регистр. Внутри одной kasmf — по порядку, сколько аргументов, столько и подстановок.

### — Как узнать, какой asm вставлен?

kasmf в процессе компиляции сам подставляет регистры и можно посмотреть результат в итоговом asm файле.

### — Почему kasmf не работает как printf (подставляет напрямую в текст)?

В отличие от строк, asm требует, чтобы всё было в регистрах. Поэтому компилятор всё выражает через регистры и только потом формирует инструкцию.

**Если остались вопросы или что-то показалось сложным — просто попробуй переписать стандартный пример, а если не получится — спроси у автора или напиши на форум сообщества!**

## Финальная ремарка

BoxLang — это язык, который можно изучить за день и который, тем не менее, позволяет собирать ядра ОС, драйверы, эмуляторы, игры и даже железо-ориентированные демонстрационные сценки благодаря своей гибкости, asm-вставкам и грамотной работе с памятью.
