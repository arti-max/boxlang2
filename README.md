# BoxLang: Документация

BoxLang — это компилируемый, статически типизированный язык программирования, созданный для разработки под кастомную 32-битную архитектуру **GovnoCore32-20020**.

Ключевая особенность языка — независимость от BIOS и операционной системы. Компилятор генерирует ассемблерный код `kasm`, который может исполняться напрямую на процессоре, что дает полный контроль над оборудованием. Основная цель проекта — создание низкоуровневых библиотек, включая графическую библиотеку, по принципам схожую с OpenGL 1.0.

## 1. Основы синтаксиса

### Комментарии

Однострочные комментарии начинаются с `##`. Все, что следует за этим символом до конца строки, игнорируется компилятором.

```rust
## Это однострочный комментарий
num32 my_var : 10 ## Присваиваем значение переменной
```


### Типы данных

В BoxLang встроено несколько базовых типов данных:


| Тип | Описание | Размер в памяти |
| :-- | :-- | :-- |
| `num32` | 32-битное целое число со знаком. | 4 байта |
| `num16` | 16-битное целое число со знаком. | 2 байта |
| `char` | 8-битный символ, хранится как ASCII-код. | 1 байт |
| `T*` | Указатель на данные типа `T`. | 4 байта |

### Числовые литералы

BoxLang поддерживает запись чисел в нескольких системах счисления, что крайне полезно для низкоуровневой разработки.

* **Десятичные (Decimal):** Обычные числа. `10`, `42`, `123`.
* **Шестнадцатеричные (Hexadecimal):** Начинаются с префикса `0x`. `0xFF` (255), `0x4A0000` (адрес палитры).
* **Двоичные (Binary):** Начинаются с префикса `0b`. `0b1111` (15), `0b111110000011111` (цвет в формате RGB555).

```rust
num32 value1 : 255
num32 value2 : 0xFF    ## То же самое число 255
num32 value3 : 0b11111111 ## И снова 255
```


### Переменные

Переменные могут быть объявлены в глобальной области видимости (вне функций) или в локальной (внутри функций).

* **Объявление:** `тип имя_переменной`
* **Объявление с инициализацией:** `тип имя_переменной : значение`
* **Присваивание:** `имя_переменной : новое_значение`

```rust
## Глобальная переменная
num32 global_counter : 0

box _start[] (
    ## Локальная переменная
    num32 local_value

    ## Присваивание
    local_value : 42
)
```


### Массивы

Массивы — это наборы элементов одного типа с фиксированным размером. Индексация начинается с 0.

```rust
## Объявление локального массива из 10 целых чисел
num32 local_array[10]

## Запись в первый элемент массива
local_array[0] : 123

## Чтение из второго элемента
num32 value : local_array[1]
```


### Указатели

Указатели — сердце низкоуровневого программирования. Они хранят не значение, а **адрес** в памяти, где это значение находится.

* **Объявление указателя:** `тип* имя_указателя`
* **Оператор взятия адреса (`&`):** Возвращает адрес переменной в памяти.
* **Оператор разыменования (`@`):** Получает или изменяет значение, хранящееся *по адресу*, который записан в указателе.


#### Ключевая концепция: Тип указателя

Это самый важный аспект для понимания.
Сам указатель, будь то `num32*`, `num16*` или `char*`, — это всегда **4-байтное число** (адрес).
Тип, стоящий *перед звёздочкой* (`T` в `T*`), говорит компилятору не о размере самого указателя, а о том, **какого размера данные** находятся по этому адресу.

* Когда вы пишете `@my_num32_ptr : 10`, компилятор записывает **4 байта**.
* Когда вы пишете `@my_num16_ptr : 10`, компилятор записывает **2 байта**.
* Когда вы пишете `@my_char_ptr : 10`, компилятор записывает **1 байт**.

Это позволяет точно управлять памятью, что необходимо для работы с оборудованием.

```rust
## Записываем 2-байтное значение цвета в палитру по адресу 0x4A0000 + (1 * 2)
num16* palette_color : 0x4A0002
@palette_color : 0b111110000011111

## Записываем 1-байтный индекс цвета в видеопамять по адресу 0x400000 + 641
char* pixel : 0x400000 + 641
@pixel : 1
```


## 2. Функции

Функции являются основными строительными блоками программы. Программа всегда начинает выполнение с функции `_start`.

* **Объявление:** `box имя_функции[параметры] ( тело_функции )`
* **Вызов:** `open имя_функции[аргументы]`
* **Возврат значения:** `ret значение`

```rust
## Функция принимает два числа и возвращает их сумму
box add_numbers[num32 a, num32 b] (
    ret a + b
)

## Основная функция
box _start[] (
    ## Вызываем функцию и сохраняем результат
    num32 result : open add_numbers[10, 5] ## result станет равен 15
)
```


## 3. Управляющие конструкции

### `if-else`

Условная конструкция для ветвления логики.

```rust
num32 a : 10
if [a < 20] (
    open print["a is less than 20$"]
) else (
    open print["a is NOT less than 20$"]
)
```


### `while`

Цикл, который выполняется, пока истинно его условие.

```rust
num32 i : 0
while [i < 5] (
    open print_num[i]
    i : i + 1
)
```


### `match-case`

Позволяет сравнить выражение с несколькими константными значениями. Блок `default` выполняется, если ни один из `case` не подошёл.

```rust
num32 x : 2
match [x] (
    case [1] (
        open print["one$"]
    )
    case [2] (
        open print["two$"]  ## Этот блок выполнится
    )
    default (
        open print["other$"]
    )
)
```


## 4. Операторы

| Категория | Оператор | Описание |
| :-- | :-- | :-- |
| **Арифметические** | `+`, `-`, `*`, `/` | Сложение, вычитание, умножение, деление. |
| **Сравнения** | `==`, `!=`, `<`, `>`, `<=`, `>=` | Равно, не равно, меньше, больше и т.д. |
| **Присваивание** | `:` | Присваивает значение переменной. |
| **Указатели** | `&`, `@` | Взятие адреса и разыменование. |

## 5. Препроцессор и стандартная библиотека

### Директива `@incl`

Позволяет включать содержимое других файлов в текущий файл перед компиляцией.

* `@incl <stdio>`: Включение системной библиотеки. Поиск ведется в стандартной папке `std/`.
* `@incl "my_functions.box"`: Включение пользовательского файла. Поиск ведется относительно текущего файла.


### Стандартные функции

Базовые функции предоставляются стандартными библиотеками.
* `stdprint`:
* `open init_text_mode[]`: Инициализирует экран в текстовый режим 80x60.
* `open clear_screen[]`: Очищает экран.
* `open print["string"]`: Выводит строку в текстовом режиме. Символ `$` интерпретируется как перенос строки.
* `open print_num[number]`: Выводит на экран число типа `num32`.
* `stdio`:
* `open VIDEO_FLUSH[]`: Принудительно обновляет экран, чтобы показать изменения в видеопамяти.
* `open trapf[]`: Вызывает отладочную ловушку для остановки эмулятора и проверки состояния.


## 6. Компиляция и запуск

Для компиляции файла BoxLang используется `main.py`.

**Команда:**

```bash
python boxlang/main.py <исходный_файл.box> [выходной_файл.asm]
```

**Пример:**

```bash
python boxlang/main.py code/test_pointers.box output.asm
```

Эта команда скомпилирует `test_pointers.box` и создаст ассемблерный файл `output.asm`, готовый для ассемблера `kasm`.

## 7. Пример "Hello World"

```rust
## Подключаем стандартные библиотеки для вывода на экран
@incl <stdprint.asm>
@incl <stdio.asm>

## Каждая программа должна иметь функцию _start
box _start[] (
    ## Инициализируем видеорежим
    open init_text_mode[]
    open clear_screen[]

    ## Выводим строку. '$' - это символ новой строки.
    open print["Hello, World!$"]

    ## Вызываем отладочную ловушку.
    ## Это остановит программу, чтобы мы могли увидеть результат.
    ## Чтобы продолжить выполнение и закрыть окно, введите в консоль эмулятора 'R' и нажмите Enter.
    open trapf[]
)
```

