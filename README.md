# BoxLang: Документация

BoxLang — это компилируемый, статически типизированный язык программирования, созданный для разработки под кастомную 32-битную архитектуру **GovnoCore32-20020**.

Ключевая особенность языка — независимость от BIOS и операционной системы. Компилятор генерирует ассемблерный код `kasm`, который может исполняться напрямую на процессоре, что дает полный контроль над оборудованием. Основная цель проекта — создание низкоуровневых библиотек, включая графическую библиотеку, по принципам схожую с OpenGL 1.0.

## 1. Основы синтаксиса

### Комментарии

Однострочные комментарии начинаются с `##`. Все, что следует за этим символом до конца строки, игнорируется.

```rust
## Это комментарий
num32 my_var : 10 ## Присваиваем значение переменной
```


### Типы данных

В BoxLang встроено несколько базовых типов данных:


| Тип | Описание | Размер | Пример |
| :-- | :-- | :-- | :-- |
| `num32` | 32-битное целое число со знаком. | 4 байта | `num32 x : 100` |
| `num16` | 16-битное целое число со знаком. | 2 байта | `num16 y : -50` |
| `char` | 8-битный символ, хранится как ASCII-код. | 1 байт | `char z : 'A'` |
| `T*` | Указатель на любой тип `T`. | 4 байта | `num32* ptr` |

### Переменные

Переменные могут быть объявлены в глобальной области видимости или внутри функций.

* **Объявление:** `тип имя_переменной`
* **Объявление с инициализацией:** `тип имя_переменной : значение`
* **Присваивание:** `имя_переменной : новое_значение`

```rust
## Глобальная переменная
num32 global_counter : 0

box _start[] (
    ## Локальная переменная
    num32 local_value

    ## Присваивание
    local_value : 42
)
```


### Массивы

Массивы — это наборы элементов одного типа с фиксированным размером.

```rust
## Объявление локального массива из 10 целых чисел
num32 local_array[^10]

## Запись в элемент массива
local_array[^0] : 123
local_array[^1] : 456

## Чтение из элемента массива
num32 value : local_array[^0]
```


### Указатели

Указатели хранят адрес в памяти. Они являются ключевым инструментом для низкоуровневого программирования.

* **Объявление указателя:** `тип* имя_указателя`
* **Оператор взятия адреса (`&`):** Получает адрес переменной.
* **Оператор разыменования (`@`):** Получает значение, хранящееся по адресу в указателе.

```rust
num32 my_var : 42

## ptr теперь хранит адрес my_var
num32* ptr : &my_var

## Чтение значения my_var через указатель
open print_num[@ptr]  ## Выведет 42

## Запись нового значения в my_var через указатель
@ptr : 999
open print_num[my_var] ## Выведет 999
```


## 2. Функции

Функции являются основными строительными блоками программы.

* **Объявление:** `box имя_функции[параметры] ( тело_функции )`
* **Вызов:** `open имя_функции[аргументы]`
* **Возврат значения:** `ret значение`

Программа всегда начинает выполнение с функции `_start`.

```rust
## Объявление функции, которая принимает два числа и возвращает их сумму
box add_numbers[num32 a, num32 b] (
    ret a + b
)

## Основная функция
box _start[] (
    num32 result : 0
    result : open add_numbers[10, 5] ## result станет равен 15
)
```


## 3. Управляющие конструкции

### `if-else`

Условная конструкция для ветвления логики.

```rust
num32 a : 10
if [a < 20] (
    open print["a is less than 20$"]
) else (
    open print["a is NOT less than 20$"]
)
```


### `while`

Цикл, который выполняется, пока истинно его условие.

```rust
num32 i : 0
while [i < 5] (
    open print_num[i]
    i : i + 1
)
```


### `match-case`

Позволяет сравнить выражение с несколькими константными значениями.

```rust
num32 x : 2
match [x] (
    case [^1] (
        open print["one$"]
    )
    case [^2] (
        open print["two$"]  ## Этот блок выполнится
    )
    default (
        open print["other$"]
    )
)
```


## 4. Операторы

| Категория | Оператор | Описание |
| :-- | :-- | :-- |
| **Арифметические** | `+`, `-`, `*`, `/` | Сложение, вычитание, умножение, деление. |
| **Сравнения** | `==`, `!=`, `<`, `>`, `<=`, `>=` | Равно, не равно, меньше, больше и т.д. |
| **Присваивание** | `:` | Присваивает значение переменной. |
| **Указатели** | `&`, `@` | Взятие адреса и разыменование. |

## 5. Препроцессор и стандартная библиотека

### Директива `@incl`

Позволяет включать содержимое других файлов в текущий файл перед компиляцией.

* `@incl <stdio.asm>`: Включение системной библиотеки в угловых скобках. Поиск ведется в стандартной папке `std/`.
* `@incl "my_functions.box"`: Включение пользовательского файла в двойных кавычках. Поиск ведется относительно текущего файла.


### Стандартные функции

Базовые функции для ввода-вывода предоставляются стандартными библиотеками.

* `open init_text_mode[]`: Инициализирует экран в текстовый режим 80x60.
* `open clear_screen[]`: Очищает экран.
* `open print["string"]`: Выводит строку на экран. Символ `$` внутри строки интерпретируется как перенос на новую строку.
* `open print_num[number]`: Выводит на экран число типа `num32`.
* `open trapf[]`: Вызывает отладочную ловушку, которая может быть использована для остановки эмулятора и проверки состояния.


## 6. Компиляция и запуск

Для компиляции файла BoxLang используется `main.py`.

**Команда для компиляции:**

```bash
python boxlang/main.py <исходный_файл.box> [выходной_файл.asm]
```

**Пример:**

```bash
python boxlang/main.py code/test_pointers.box output.asm
```

Эта команда скомпилирует `test_pointers.box` и создаст ассемблерный файл `output.asm`, готовый для ассемблера `kasm`.

## 7. Пример "Hello World"

```rust
## Подключаем стандартные библиотеки для вывода на экран
@incl <stdprint.asm>
@incl <stdio.asm>

## Каждая программа должна иметь функцию _start
box _start[] (
    ## Инициализируем видеорежим
    open init_text_mode[]
    open clear_screen[]

    ## Выводим строку. '$' - это символ новой строки.
    open print["Hello, World!$"]

    ## Объявляем счетчик для цикла
    num32 i : 0

    ## Цикл от 0 до 4
    while [i < 5] (
        open print["Number: "]
        open print_num[i]
        open print["$"]
        i : i + 1
    )

    ## Вызываем отладочную ловушку для остановки программы (вообще это чисто для отладки, но если её не указать, то программа сразу завершится и окно закроется, а так тут, чтобы продолжить ей и закрыть окно надо в консоль ввести R)
    open trapf[]
)
```

